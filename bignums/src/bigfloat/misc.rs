use crate::bigfloat::BigFloat;

impl BigFloat {
	pub fn agm(&self, other: &BigFloat, prec: i64) -> BigFloat {
		if self.is_negative() || other.is_negative() {
			panic!("agm() only works for positive numbers");
		}

		if self.is_zero() || other.is_zero() {
			return BigFloat::ZERO;
		}

		let actual_prec = i64::max(prec + 2, 1);
		let working_prec =
			actual_prec + actual_prec.ilog2() as i64 + self.ilog2().max(other.ilog2());

		let mut a = self.add_with_precision(other, working_prec) >> 1u32;
		let mut b = self
			.mul_with_precision(other, working_prec)
			.sqrt(working_prec);

		loop {
			let tmp = a.add_with_precision(&b, working_prec) >> 1;
			b = a.mul_with_precision(&b, working_prec).sqrt(working_prec);
			a = tmp;
			let delta = a.sub_with_precision(&b, working_prec);
			if delta.is_zero() || delta.ilog2() + 1 < -actual_prec {
				break;
			}
		}

		b.round_to_precision(actual_prec);
		b
	}
}

#[cfg(test)]
mod tests {
	use super::*;

	#[test]
	fn test_agm() {
		let x = "1";
		let y = "2";
		let expected = "1.45679103104690686918643238326508197497386394322130559079417238326\
		79264545802509002574737128184484443281894018160367999355762430743401245116912132499522793\
		76897021197672689372826666678270743290207238456460096313336749441664951640082693223908626\
		33767383824102548872626451365906604088758851004667281309474397893551291172017544718695641\
		60356411130706061251704009727453745213704014201441576823232389645029091322392292018630204\
		59196677536211529560998432049400961861338863911084030381488628159073170114235547302303533\
		6262089868356130800759857031212508135717335336062724964171456";
		test_agm_helper(x, y, expected, 1000);

		let x = "1";
		let y = "10000";
		let expected = "1482.353938588148940512220229357140996209973532602931942348425969270\
		868778620166863341029329858236411832976159616358943952299398485171651431446795548473443891\
		125805551124750511175033026591273078809622663253093870597591536471342343717421555269858378\
		709082730574852191356262035282998748893360074107603647700263943071182454991380580340989202\
		576426346970120937789275999727731628592469658816640473914185295522425828158485135256878581\
		180273457171044085849483922738682087313909110698784997468079648109541092541887488133067419\
		40687957696157091901799785341172757689153767583904051";
		test_agm_helper(x, y, expected, 1000);

		let x = "0.000025";
		let y = "10000000505";
		let expected = "448686416.0277447516711522685542323656147396821316265382013359205429\
		163356536675268387661826629923371649435089303338388871219729773249487580507070433425339439\
		164410055077351379571189292391682555913927081158759706260400274482537453815244145452478517\
		544229267949294743407342400355949022201778945342656271998874063619611193975222379141355593\
		551594561316709442924509696848455352786442963291683673460786323197624460335877515418316709\
		477082388030100044018913005663687544649080171384776884598854528929933407120357049063681517\
		200207408428388671703483578531289391011686099088704767";
		test_agm_helper(x, y, expected, 1000);
	}

	fn test_agm_helper(x: &str, y: &str, expected: &str, prec: i64) {
		let x = BigFloat::from_str_with_precision(x, prec + 64).unwrap();
		let y = BigFloat::from_str_with_precision(y, prec + 64).unwrap();
		let expected = BigFloat::from_str_with_precision(expected, prec + 64).unwrap();
		let actual = x.agm(&y, prec);
		let delta = (&actual - &expected).abs();
		let epsilon = BigFloat::ONE >> prec;

		println!("expected: {expected}\nactual: {actual}\ndelta: {delta}\nepsilon: {epsilon}\n");
		assert!(delta < epsilon);
	}
}
