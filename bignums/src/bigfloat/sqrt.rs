use crate::bigfloat::BigFloat;
use crate::bigint::BigInt;

impl BigFloat {
	pub fn sqrt(&self, prec: i64) -> BigFloat {
		if self.is_negative() {
			panic!("Cannot take sqrt of negative number");
		}
		if self.is_zero() {
			return BigFloat::ZERO;
		}
		if self.is_one() {
			return BigFloat::ONE;
		}

		let actual_prec = prec + 2;
		let working_prec = actual_prec + 16;

		let mut x = Self::est_sqrt(self.clone());

		loop {
			let q = self.div(&x, working_prec);
			let delta = x.sub_with_precision(&q, working_prec);
			x = x.add_with_precision(&q, working_prec) >> 1;

			if delta.is_zero() || delta.ilog2() + 1 <= -actual_prec {
				break;
			}
		}

		x.round_to_precision(actual_prec);
		x
	}

	fn est_sqrt(x: BigFloat) -> BigFloat {
		let mut shift = x.m.magnitude.ilog2() as i64;
		if (x.e + shift) % 2 != 0 {
			shift += 1;
		}
		let n = (x.e + shift) / 2;

		let a = BigFloat::from_mantissa_exponent(BigInt::ONE, n - 1);
		let b = BigFloat::from_mantissa_exponent(x.m, n - shift - 1);
		&a + &b
	}
}

#[cfg(test)]
mod tests {
	use core::ops::Sub;

	use super::*;

	#[test]
	fn test_sqrt() {
		let a = "2";
		let a_sqrt = "1.414213562373095048801688724209698078569671875376948073176679737990\
		7324784621070388503875343276415727350138462309122970249248360558507372126441214970999358\
		3141322266592750559275579995050115278206057147010955997160597027453459686201472851741864\
		0889198609552329230484308714321450839762603627995251407989687253396546331808829640620615\
		2583523950547457502877599617298355752203375318570113543746034084988471603868999706990048\
		1503054402779031645424782306849293691862158057846311159666871301301561856898723723528850\
		9264861249497715421833420428568606014682472077143585487415565706967765372022648544701585\
		8801620758474922657226002085584466521458398893944370926591800311388246468157082630100594\
		8587040031864803421948972782906410450726368813137398552561173220402450912277002269411275\
		7362728049573810896750401836986836845072579936472906076299694138047565482372899718032680\
		2474420629269124859052181004459842150591120249441341728531478105803603371077309182869314\
		7101711116839165817268894197587165821521282295184884720896946338628915628827659526351405\
		4226765323969461751129160240871551013515045538128756005263146801712740265396947024030051\
		749531886292563138519";
		test_sqrt_helper(a, a_sqrt, 1000);

		let a = "10000";
		let a_sqrt = "100";
		test_sqrt_helper(a, a_sqrt, 1000);

		let a = "100015.122";
		let a_sqrt = "316.2516750943779586164923884235295356712751348386783614459801743445\
		6493419212284857016196386003723075362270370298134673472768324930207591859745017902034148\
		7646721206153749908728788233063435085309069763324759169493592076141829564340671427159693\
		7980689028740078226240854563877984186734972869700595581463682054469500124925472934231726\
		6542755541749523166173382828041000117512268661853876943255010014792161565332242583658130\
		7442799687557035076452154516362657282619926253339406272557537596708445112111059199109928\
		3143144402439589976310413591104537731987907403988015315028882934";
		test_sqrt_helper(a, a_sqrt, 200);

		let a = "0.0000000000045";
		let a_sqrt = "0.00000212132034355964257320253308631454711785450781306542210976501960\
			69860987176931605582755813014914623591025207693463684455373872540837761058189661822456\
			49903747119833998891258389133699925751729173090857205164339957408955411801895293022092\
			776127961333797914328493845726463071482176259643905";
		test_sqrt_helper(a, a_sqrt, 200);
	}

	fn test_sqrt_helper(x: &str, expected: &str, prec: i64) {
		let x = BigFloat::from_str_with_precision(x, prec + 64).unwrap();
		let expected = BigFloat::from_str_with_precision(expected, prec + 64).unwrap();
		let actual = x.sqrt(prec);
		let delta = actual.sub(&expected).abs();
		let epsilon = BigFloat::ONE >> prec;

		print!("expected: {expected}\nactual: {actual}\ndelta: {delta}\nepsilon: {epsilon}\n\n");
		assert!(delta < epsilon);
	}
}
